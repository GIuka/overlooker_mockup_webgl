<!DOCTYPE html>
<html lang="">

<head>
  <title>Overlooker</title>
  <link href="style.css" rel="stylesheet" type="text/css" />
  <meta charset="utf-8">
  <script src="libraries/twgl-full.min.js"></script>

  <script id="vertex_texture" type="notjs">
    precision highp float;
    
    attribute vec2 a_position;
    attribute vec2 a_texcoord;
    varying vec2 v_texcoord;
      
    void main() {
      gl_Position = vec4(a_position, 1.0, 1.0);
      v_texcoord = 0.5 * a_position.xy + 0.5;
    }
          </script>
  <script id="vertex_screen" type="notjs">
  precision highp float;

  attribute vec2 a_position;
  attribute vec2 a_texcoord;
  uniform mat3 u_matrix;
  varying vec2 v_texcoord;
  
  void main() {
    // Transforms the x and y coordinates of the quad's vertices to preserve
    // aspect ratio of the tiles.
     gl_Position = vec4(u_matrix * vec3(a_position, 1.0), 1.0);
     v_texcoord = 0.5 * a_position.xy + 0.5;
  }
      </script>
  <script id="fragment_texture" type="notjs">
  precision highp float;

  uniform vec2 u_resolution;
  uniform vec2 u_mouse;
  uniform float u_time;
  uniform float u_interval;
  uniform vec3 u_colortheme[6];
  uniform sampler2D u_texture_data;

  varying vec2 v_texcoord;

  // Matches the data texture's state codes with the colors from the theme.
  vec4 matchColorCode(in float _code) {
    vec4 _color = vec4(0.0);
    if (_code == 0.0) {         
      if (u_colortheme[0].r + u_colortheme[0].g + u_colortheme[0].b < 1.5) {
        _color = vec4(u_colortheme[0].rgb + vec3(0.15), 1.0);
      } else {
        _color = vec4(u_colortheme[0].rgb - vec3(0.15), 1.0);
      }                         // neverInitialized
      _color.xyz = clamp(_color.rgb, 0.0, 1.0); 
    } else if (_code <= 0.2) {
      _color.xyz = u_colortheme[1]; // Available
    } else if (_code <= 0.4) {
      _color.xyz = u_colortheme[2]; // previewing
    } else if (_code <= 0.6) {
      _color.xyz = u_colortheme[3]; // OnCall
    } else if (_code <= 0.8) {
      _color.xyz = u_colortheme[4]; // AfterCall
    } else {
      _color.xyz = u_colortheme[5]; // LoggedOut
    }
    _color.w = 1.0;
    return _color;
  }

  // References an animation's endpoint and duration to a looping timer to get
  // its normalized progress.
  float mapTime (float start, float end, float duration, float timer) {
    float reference_timer = timer;
    float time_left = 256.0 - reference_timer;

    // An animation with an endpoint less than its duration spans the beginning
    // and ending regions of the timer number line. Fixed by projecting
    // reference_timer left of the number line once it hits the animation's
    // starting point.
    if (end < duration && time_left <= duration - end) {
        reference_timer = -time_left;
    }
    return clamp((reference_timer - start) / (end - start), 0.0, 1.0);
  }

  void main() {
    vec4 tex_color = texture2D(u_texture_data, v_texcoord);
    float colormix_end = 255.0 * tex_color.w;
    float colormix_start = colormix_end - u_interval;
    float mix_amount = mapTime(colormix_start, colormix_end, u_interval, u_time);

    vec4 start_color = matchColorCode(tex_color.x);
    vec4 end_color = matchColorCode(tex_color.y);
    vec4 mixed = vec4(mix(start_color.rgb, end_color.rgb, mix_amount), 1.0);
    
    gl_FragColor = mixed;
  }

  </script>
  <script id="fragment_screen" type="notjs">
  precision highp float;
  
  uniform vec2 u_resolution;
  uniform vec2 u_mouse;
  uniform float u_aafactor;
  uniform vec3 u_gridparams;
  uniform vec3 u_colortheme[6];
  uniform sampler2D u_texture_color;
  varying vec2 v_texcoord;

  // Uses the dot product of the input coord and the circle's center to test if
  // a pixel lies on the circle. Dot product is used instead of distance formula
  // because 1 trig function is faster than 1 sqrt + 2 exp.
  float circle_dot(in vec2 _uv) {
    float radius = u_gridparams.z / 2.0;
    vec2 centered = _uv.xy * vec2(2.0) - vec2(1.0);
    float d = 0.5 * dot(centered, centered) + radius;
    return smoothstep(0.5 + u_aafactor, 0.5 - u_aafactor, d);
  }

  void main() {
    // The quad spans the screen, so uv coords are used instead of frag coords
    // to keep each circle aligned with its color.
    vec2 uv = v_texcoord.xy;

    // Draws a grid by looping the screenspace horizontally by the number of
    // grid columns and vertically by the number of grid rows.
    uv.xy = fract(uv.xy * u_gridparams.xy);

    vec4 tex_color = texture2D(u_texture_color, v_texcoord);
    gl_FragColor = vec4(mix(u_colortheme[0].rgb, tex_color.rgb, circle_dot(uv)), 1.0);
  }
      </script>
</head>

<canvas id="cgl" >
</canvas>

<body>
  <div class="tooltipbody">
    <span class="tooltip"></span>
  </div>
</body>
<script src="call_center_mockup.js"></script>
</html>
