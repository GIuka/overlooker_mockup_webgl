<!DOCTYPE html>
<html lang="">

<head>
  <title>Overlooker</title>
  <link href="style.css" rel="stylesheet" type="text/css" />
  <meta charset="utf-8">
  <script src="libraries/twgl-full.min.js"></script>
</head>

<body>
  <canvas id="cgl">
    <script id="vertex_texture" type="notjs">
    precision mediump float;
    
    attribute vec2 a_position;
    attribute vec2 a_texcoord;
    
    uniform mat3 u_matrix;
    varying vec2 v_texcoord;
      
    void main() {
      gl_Position = vec4(a_position, 1.0, 1.0);
      v_texcoord = a_position.xy * 0.5 + 0.5;
    }
          </script>
    <script id="vertex_screen" type="notjs">
  precision mediump float;

  attribute vec2 a_position;
  attribute vec2 a_texcoord;

  uniform mat3 u_matrix;
  varying vec2 v_texcoord;
  varying vec2 v_texcoord_data;
  
  void main() {
     gl_Position = vec4(u_matrix * vec3(a_position, 1.0), 1.0);
     v_texcoord = 0.5 * a_position.xy + 0.5;
  }
      </script>
    <script id="fragment_texture" type="notjs">
  precision mediump float;

  uniform vec2 u_resolution;
  uniform vec2 u_mouse;
  uniform float u_time;
  uniform float u_timescale;
  uniform vec3 u_gridparams;
  uniform vec4 u_colortheme[6];
  uniform sampler2D u_texture_data;

  varying vec2 v_texcoord;

  vec4 colorCheck(in float _code) {
    vec4 _color = vec4(0.0);
    if (_code <= 0.0) {
      if (u_colortheme[5].x + u_colortheme[5].y + u_colortheme[5].z < 1.0) {
        _color = u_colortheme[5] + vec4(0.15); // Uninit
      } else {
        _color = u_colortheme[5] - vec4(0.1); // Uninit
      }
      _color.a = 1.0;
      _color = clamp(_color, 0.0, 1.0);
    } else if (_code <= 0.2) {
      _color = u_colortheme[0]; // OnCall
    } else if (_code <= 0.4) {
      _color = u_colortheme[1]; // Available
    } else if (_code <= 0.6) {
      _color = u_colortheme[2]; // PreviewingTask
    } else if (_code <= 0.8) {
      _color = u_colortheme[3]; // AfterCall
    } else {
      _color = u_colortheme[4]; // LoggedOut
    }
    return _color;
  }

  void main() {
    vec4 tex_color = texture2D(u_texture_data, v_texcoord);
    vec4 start_color = colorCheck(tex_color.x);
    vec4 end_color = colorCheck(tex_color.y);
    float t = tex_color.w;
    float s = clamp(t, 0.0, 1.0);

    vec4 shaded = vec4(mix(start_color.xyz, end_color.xyz, s), 1.0);
    gl_FragColor = shaded;
  }

  </script>
    <script id="fragment_screen" type="notjs">
  precision mediump float;
  
  uniform vec2 u_resolution;
  uniform vec2 u_mouse;
  uniform float u_time;
  uniform float u_timescale;
  uniform vec3 u_gridparams;
  uniform vec4 u_colortheme[6];
  uniform sampler2D u_texture_color;
  uniform sampler2D u_texture_data;
  varying vec2 v_texcoord;

  float aa_factor = u_gridparams.y * 1.5 / u_resolution.y;
  float radius = u_gridparams.z / 2.0;

  // Distance formula approach to drawing a circle:
  float circle_dist(in vec2 _uv) { 
    float d = length(_uv.xy * 2.0 - vec2(1.0));
    float t = 1.0 - smoothstep(0.5 + aa_factor, 0.5 - aa_factor, d * 0.51);
    return 1.0 - t;
  }

  // Dot product approach to drawing a circle:
  float circle_dot(in vec2 _uv) {
    vec2 centered = _uv.xy * vec2(2.0) - vec2(1.0);
    float d = 0.5 * dot(centered, centered) + radius;
    return smoothstep(0.5 + aa_factor, 0.5 - aa_factor, d);
  }

  void main() {
    vec2 pixelCoords = gl_FragCoord.xy + vec2(0.5);
    vec2 mapped = pixelCoords / u_gridparams.xy;
    vec4 tex_color = texture2D(u_texture_color, v_texcoord);

    vec2 uv = v_texcoord.xy;
    uv.xy = fract(u_gridparams.xy * uv.xy); // Split screen into divisions.

    gl_FragColor = vec4(mix(u_colortheme[5].xyz, tex_color.xyz, circle_dot(uv)), 1.0);
  }
 
      </script>
  </canvas>
</body>
<script src="call_center_mockup.js"></script>

</html>
